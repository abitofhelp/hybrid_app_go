@startuml 05_static_vs_dynamic_dispatch
!theme plain
skinparam linetype ortho

title Static vs Dynamic Dispatch - Dependency Injection in Ada

package "Dynamic Dispatch\\n(Runtime Polymorphism)" as DynamicPkg #FFE4E1 {
  interface Writer_Port <<interface>> {
    +Write(Message)
  }

  class Console_Writer {
    +Write(Message)
  }

  class Greet_UseCase {
    -Writer : Writer_Port'Class
    +Execute()
  }

  Console_Writer .up.|> Writer_Port
  Greet_UseCase o-right-> Writer_Port : depends
}

package "Static Dispatch\\n(Compile-Time Polymorphism)" as StaticPkg #E8F5E9 {
  class "Console_Writer" as StaticCW <<function>> {
    Write(Message)
  }

  class "Generic\\nGreet_UseCase" as StaticGUC <<generic package>> {
    **generic**
    with function Writer(...)
    **package** Greet
  }

  class "Instantiation" as StaticInst <<wired at compile time>> {
    package Greet_With_Console
    is new Greet(Writer => CW.Write)
  }

  StaticCW .down.> StaticInst
  StaticGUC .down.> StaticInst
}

note right of Greet_UseCase
  **Runtime Cost:**
  • Vtable lookup
  • Heap allocation
  • No inlining

  **Benefits:**
  • Runtime flexibility
end note

note right of StaticGUC
  **Compile-Time Cost:**
  • Zero overhead
  • Direct call (inlined)
  • Stack allocation

  **Trade-off:**
  • Fixed at compile time
end note

note bottom of StaticPkg
  **This Project Uses Static Dispatch**
  All dependency injection via generics
  for maximum performance
end note

@enduml
